# 第二章 搜索技术

## 2.1 引子

人工智能虽有多个应用领域，而且每个应用领域又各有自己的规律和特点，但从它们求解具体问题的过程来看，都可抽象为一个“问题求解”的过程。

## 2.2 搜索问题

### 2.2.1 搜索问题概念

能用搜索技术解决的问题称之为**搜索问题**。

**搜索问题**：已知问题的初始状态和目标状态，求解一个操作序列使得问题能从初始状态转移到目标状态。

**最优搜索问题**：如果所求序列可以使得总代价最低，则问题称为最优搜索问题。

搜索问题的特征：

• 初始状态是确定的

• 当前状态是否为目标状态是可以检测的

• 状态空间是离散的

• 每个状态可以采取的合法行动和相应后继状态是确定的

• 环境是静态的

• 路径的代价函数是已知的(路径：从一个状态转移到下一个状态所走的一个步骤)

### 2.2.2 四个搜索问题实例

8-数码难题（重排九宫格）、八皇后问题、旅行销售员问题、传教士野人问题。

> 搜索问题四个要素：

1. **初始状态**：所处的初始状态。

2. **后继函数**：某种行动（操作），输入给定状态，可以输出相应的后继状态

3. **目标测试**：用来确定给定的状态是否为目标状态

4. **路径代价函数**：在两个给定状态之间进行转移所需的“代价”

> 搜索问题分类：

1. **普通搜索问题**：求出一条从初始状态到目标状态之间的行动序列

2. **全局搜索问题**：求出所有从初始状态到目标状态之间的行动序列

3. **最优化搜索问题**：求出从初始状态到目标状态之间所需代价最少的行动序列

## 2.3 搜索问题的表示

### 2.3.1 状态空间表示法

要求解搜索问题，首先要解决的是：用什么样的形式把问题表示出来。

- 状态空间表示法

- 与/或树表示法

> 状态空间表示法

- 表示**问题及其搜索过程**的一种形式化的表示方法

- 使用**状态空间图**(状态图)描述问题

- 许多问题可以归结为在**某一状态图中寻找目标或路径的问题**

> 状态空间表示法含义

- 状态空间表示法用“**状态**”和“**算符**”来表示问题

  - “**状态**”用以描述问题求解过程不同时刻的状态
  
  - “**算符**”表示对状态的操作，算符的每一次使用就使问题由一种状态变换为另一种状态。

- 当达到目标状态时，由初始状态到目标状态所**用算符的序列就是问题的一个解**。

> 状态和算符

1. 状态

    是描述问题求解过程中任一时刻状况的数据结构，可用一组变量的有序集表示

2. 算符

    引起状态中某些分量发生变化，从而**使问题由一个状态变为另一个状态的操作**称为算符。

3. 状态空间

    由问题的全部状态及一切可用的算符所构成的集合称为问题的状态空间，一般用一个三元组表示：(S，F，G)
    其中，S是问题的所有初始状态构成的集合；F是算符的集合；G是目标状态的集合。

4. 状态空间图
    状态空间的图示形式称为状态空间图。其中，**节点**表示状态，**有向边**（弧）表示算符。

5. 问题的解

    状态空间的一个解：一个有限的操作算符的序列

> 状态空间表示法要点

1. 用状态空间表示，首先必须定义状态的描述形式，把问题的一切状态都表示出来，其次定义算符，完成状态的转换。

2. 问题的求解过程就是一个把算符不断地作用于状态的过程，如果在使用某个算符后得到的状态就是目标状态，就得到了问题的解，这个解就是从初始状态到目标状态所用算符构成的序列。

3. 算符的一次使用，就使问题由一种状态转变为另一种状态，可能有多个算符序列都可使问题从初始状态变到目标状态，这就得到了多个解。

4. 对任何一个状态，可使用的算符可能不止一个，这样由一个状态所生成的后继状态可能有多个。如何选择下一步的操作，由搜索策略决定。

## 2.4 解的搜索

### 2.4.1 生成与测试范例

解决问题的直接方法是提出可能的解，然后检查每个可能解，看是否有可能构成了解，这个过程称之为**生成与测试范**。

一个好的生成器应该是：

- **完备的**

- **知情的**

- **非冗余的**

### 2.4.2 基本搜索策略

> 搜索策略

- 穷举法

- 回溯法

- 贪心算法

> 1.穷举法

- 一种穷尽所有可能解的搜索方法

- 即使在发现当前步骤不可能找到成功的解，还是会进一步探索局部的解决方案

> 2.回溯法

- 回溯法是对穷举法的改进

- 不探测不可能的路径

- 提出解的过程被分为几个阶段

> 3.贪心算法

- 是另一种经典搜索方法

- 把问题分成若干步骤来处理

- 每一步都包含必须优化的目标函数

- 在每一步选择当前最佳选择

### 2.4.3 搜索的基本过程

> 状态空间上进行搜索的基本过程：

- 首先为问题选择适当的“状态”及“操作”的形式化描述方法；

- 然后从某个初始状态出发，每次使用一个“操作”，递增地建立起操作序列，直到达到目标状态为止；

- 此时，由初始状态到目标状态所使用的算符序列就是该问题的一个解。

> 搜索一般过程

1. 搜索过程具有通用性

    对OPEN表上的节点进行排序的准则，以便选出一个“最好”的节点作为扩展使用。

   - 排序是任意的，即盲目的——盲目搜索。

   - 排序用启发信息为依据——启发式搜索。

2. 搜索图和搜索树

   - 图搜索的一般过程中生成的明确的图，被称为搜索图G 。

   - 由图G中所有节点及反向指针（返回节点n的指针）构成的集合T，是一棵树，称为搜索树。

3. 搜索过程终止条件

   - **有解**：当被选作扩展的节点是目标节点时，搜索过程成功结束，得到了一个解。

   - **无解**：当搜索树不再有末被扩展的端节点时，即OPEN表为空，搜索过程失败，从初始节点达不到目标节点。

> 搜索一般过程：要点

- 必须记住下一步还可以走哪些点
    OPEN表（记录还没有扩展的点）

- 必须记住哪些点走过了
    CLOSED表（记录已扩展的点）

- 必须记住从目标返回的路径
    每个表示状态的节点结构中必须有指向父节点的指针

## 2.5 盲目搜索

搜索根据是否运用与问题有关的信息分为**盲目搜索**和**启发式搜索**。

盲目搜索：按预定的控制策略进行搜索，在搜索过程中获得的中间信息不用来改进控制策略。这种搜索不需重排OPEN表，具有盲目性，效率不高，不便于复杂问题的求解。

启发式搜索：也成为知情搜索，在搜索中加入了与问题有关的启发性信息，用以指导搜索朝着最有希望的方向前进，加速问题的求解过程并找到最优解。

### 2.5.1 广度优先搜索(DFS)

广度优先搜索(Breadth-First Search)又称为宽度优先搜索，简称为BFS。

> 广度优先搜索的基本思想

- 广度优先搜索是指从初始节点S开始，向下逐层搜索。

- 在n层节点未搜索完之前，不进入n+1层搜索。

- 同层节点的搜索次序可以任意。

> 广度优先搜索过程：

先按生成规则生成第一层节点，在该层全部节点中沿宽（广）度进行横向扫描，检查目标节点Sg是否在这些子节点中。

若没有，则再将所有第一层节点逐一扩展，得到第二层节点，并逐一检查第二层节点中是否包含有Sg，如此依次按照先生成、先检查、先扩展的原则进行下去，直到发现Sg为止。

> 广度优先搜索流程

1. 把初始节点S0放入OPEN表；

2. 如果OPEN表为空，则问题无解，失败并退出。否则往下。

3. 把OPEN表中的第一个节点取出放入CLOSED表中，并按顺序冠以编号n；

4. 考察节点n是否为目标节点。若是，则求得了问题的解，成功并退出。否则往下。

5. 若节点n不可扩展，则转第(2)步；

6. 扩展节点n，将其子节点放到OPEN表的尾部，并为每一个子节点都配置指向父节点的指针，然后转第(2)步。

广度优先搜索的OPEN表采用先进先出（FIFO）的数据结构。

一旦节点被扩展，它的子节点就会移动到开放列表（OPEN表）的尾部。

只有在其父节点所在层中的每个其他节点被访问之后，才会探索这些子节点。

### 2.5.2 深度优先搜索(BFS)

深度优先搜索(Depth-First Search)是一种一直向下的搜索策略。

从初始节点S0开始，按生成规则生成下一级各子节点，检查是否出现目标节点Sg。

若未出现，则按“最晚生成的子节点优先扩展”的原则，再生成再下一级的子节点，再检查是否出现Sg；若仍未出现，则再沿着最晚生成的子节点分枝生成子节点，如此下去，即逐级“纵向”深入搜索。故称为“深度优先搜索法”。

> 深度优先搜索的流程

1. 把初始节点S0放入OPEN表；

2. 如果OPEN表为空，则问题无解，失败并退出。

3. 把OPEN表中的第一个节点取出放入CLOSED表中，并按顺序冠以照编号n

4. 考察节点n是否为目标节点。若是，则求得了问题的解，成功并退出。

5. 若节点n不可扩展，则转第(2)步；

6. 扩展节点n，将其子节点放到OPEN表的**首部**，并为其配置指向父节点的指针，然后转第(2)步。

由于一个有解的问题常常含有无穷分枝，深度优先搜索过程如果误入无穷分枝，就不可能找到目标节点，所以它是**不完备的**。

### 2.5.3 广度、深度优先搜索比较

> 搜索算法性能的度量

- 完备性——当一个算法被保证在有解的情况下找到解时，它就是完备的

- 最优性——算法是最优的，如果它提供了所有解中代价最低的路径

- 时间复杂度——以搜索过程中生成的节点数来度量

- 空间复杂度——执行搜索需要多少内存。

> 广度优先搜索与深度优先搜索的比较

1. 如果是以下几种情况，则首选BFS：

   - 分支因子不是太大(因此内存成本低)

   - 问题的解出现在相对较浅的水平

   - 没有一条路径是特别深的

2. 如果是以下几种情况，则首选DFS

   - 树很深

   - 分支因子并不过多

   - 问题的解出现在树的深处

|| BFS | DFS |
|----|----|----|
|完备性|完备|非完备|
|最优性|最优|非最优|
|时间复杂度|O(b^d)|O(b*m)|
|空间复杂度|O(b^d)|O(b*m)|

### 2.5.4 有限深度优先搜索与迭代加深的深度优先搜索(DFS-ID)

有限深度优先搜索的基本思想：深度截止于k的深度有限搜索（k以下深度的节点不再扩展）

## 2.6 小结
