# 第三章 知情搜索

## 3.1 启发搜索

> 盲目搜索存在问题

- 效率低 、 存储空间大

- 组合爆炸

> 启发

一种解决问题的方法，这种方法通过尝试来证明结果，是“凭经验”或“试错法”的学习方式。

- 启发：作为一个名词，是指特定的“经验法则”或是从经验衍生出来的论据。

- 应用相关问题的启发式知识求解问题就称为启发法。

> 启发法

- 启发法是一个提高复杂问题解决效率的实用策略

- 它引导程序沿着一条最可能的路径到达解，忽略最没有希望的路径

- 能避免去检查死角

- 只使用已搜集的数据

- 启发法可以减少节点数目，适合组合复杂度快速增长的问题

- 启发法使用知识、信息、规则、见解、类比和简化等技术减少必须检查的对象数目

- 好的启发式方法不能保证获得解，但是它们经常有助于引导人们达到解的路径

> 启发式搜索

- 启发式搜索，也称为有信息搜索或知情搜索 ，借助问题的特定知识来帮助选择搜索方向。

- 在搜索过程中对待扩展的每一个节点进行评估，得到最好的位置再从这个位置进行搜索直到目标。

- 启发式搜索的目的是省略大量无谓的搜索路径，提高效率。

- 在启发式搜索中，**对节点的评价**是十分重要的，评价函数是搜索成败的关键。

> 估价函数——评估节点重要性的函数

- 估价函数：也称为启发函数，用来提供问题的启发性信息

- 按其用途划分，可分为以下三类：

  - 用于扩展节点的选择，即用于决定应先扩展哪一个节点以免盲目扩展

  - 用于生成节点的选择，即用于决定应生成哪些后续节点以免盲目地生成过多无用节点

  - 用于删除节点的选择，即用于决定应删除哪些无用节点以免造成进一步的时空浪费

> 估价函数一般形式

f(n) = g(n) + h(n)

- g(n)：从初始节点S0到当前节点n的代价

- h(n)：从节点n到目标节点Sg的最优路径的代价的估计，它体现了问题的启发性信息。

- f(n)：从初始节点S0到达目标节点Sg的最优路径的估计值。

## 3.2 知情搜搜——找到任何解

### 3.2.1 爬山法、最陡爬山法

> 爬山法

- 爬山法是一种贪心算法

- 爬山法是一种局部择优的方法

- 不保存未选择路径的记录

- 可能更接近顶部的目标节点就是山顶但是你可能无法从当前位置到达目标目的地

- 不存储历史记录

- 没有能力从错误中或错误路径中恢复

- 局部贪心的最优算法

> 爬山法主要思想

1. 随机选择一个登山的起点

2. 每次**拿相邻点与当前点**进行比对取两者中较优者作为爬坡的下一步

3. 重复第2步直至该点的邻近点中不再有比其大的点

4. 选择该点作为本次爬山的顶点即为该算法获得的最优解。

爬山法特点：

- 在任何一点都要做出一个选择

- 不确定是否在正确的路径上

> 最陡爬坡法

伪代码：

```C++
  Hillclimbing(Root_Node, goal){
    if(Root_Node = goal) return 成功;
    建立open表；将根节点的所有子节点插入open表；
    While(open表不为空){
      找到离目标具有最小距离的子节点；
    }end while
    最优子节点 = 离目标具有最小距离的子节点；
    if(最优子节点不是叶子结点) 以当前子节点为根结点，递归调用自身;
    else If (最优子节点 = goal) return 成功
      return 失败；
}
```

### 3.2.2 爬山法的问题

> 爬山法的问题

- 山麓问题

- 高原问题

- 山脊问题

> 山麓问题

- 可能会困在局部最大值中

- 目标状态不能从当前的位置到达

> 高原问题

相似的局部最大值

> 山脊问题

虽然可能更接近目标但是在错误的层上

> 可能的补救方法

- 回溯

- 返回到被截掉的节点

- 多次应用相同的规则(达到问题解的新区域)

- 同时应用多个规则(避免山脊问题)

### 3.2.3 最佳优先搜索算法

> 最佳优先搜索思想

1. 是智能搜索算法

2. 决定探索哪些节点

3. 实现也需要open表和closed表

4. open表中节点按照节点接近目标状态的启发式估计值进行顺序排列

5. 不会保留重复状态

6. 效率取决于所使用的启发式测度的有效性

伪代码：

```C++
  // 最佳优先搜索
  BestFirstSearch(Root_Node, goal){
    建立open表；将根节点插入open表；
    While(open表不为空){
      从open表中取出最前节点放在节点G中(同时加入closed表);
      if(G是目标节点)返回从根节点到G节点一条路径。
      while(G有子节点){
        if(子节点不在open表中)将子节点插入open表;
        else 将具有最小估计值的子节点放入open表，删除其他节点;
      } //end of second while
      将open表中节点按值排序；最小值节点在最前
    }//end of first while
    return 失败;
  }
```

## 3.3 知情搜索——找到最优解

### 3.3.1 分支定界法

### 3.3.2 低估值的分支定界法

### 3.3.3 采用动态规划的分支定界法

### 3.3.4 A*搜索

## 3.4 知情搜索——高级搜索算法：约束满足搜索

### 3.4.1 高级搜索算法

## 3.5 小结
