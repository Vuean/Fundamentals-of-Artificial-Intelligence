# 第三章 知情搜索

## 3.1 启发搜索

> 盲目搜索存在问题

- 效率低 、 存储空间大

- 组合爆炸

> 启发

一种解决问题的方法，这种方法通过尝试来证明结果，是“凭经验”或“试错法”的学习方式。

- 启发：作为一个名词，是指特定的“经验法则”或是从经验衍生出来的论据。

- 应用相关问题的启发式知识求解问题就称为启发法。

> 启发法

- 启发法是一个提高复杂问题解决效率的实用策略

- 它引导程序沿着一条最可能的路径到达解，忽略最没有希望的路径

- 能避免去检查死角

- 只使用已搜集的数据

- 启发法可以减少节点数目，适合组合复杂度快速增长的问题

- 启发法使用知识、信息、规则、见解、类比和简化等技术减少必须检查的对象数目

- 好的启发式方法不能保证获得解，但是它们经常有助于引导人们达到解的路径

> 启发式搜索

- 启发式搜索，也称为有信息搜索或知情搜索 ，借助问题的特定知识来帮助选择搜索方向。

- 在搜索过程中对待扩展的每一个节点进行评估，得到最好的位置再从这个位置进行搜索直到目标。

- 启发式搜索的目的是省略大量无谓的搜索路径，提高效率。

- 在启发式搜索中，**对节点的评价**是十分重要的，评价函数是搜索成败的关键。

> 估价函数——评估节点重要性的函数

- 估价函数：也称为启发函数，用来提供问题的启发性信息

- 按其用途划分，可分为以下三类：

  - 用于扩展节点的选择，即用于决定应先扩展哪一个节点以免盲目扩展

  - 用于生成节点的选择，即用于决定应生成哪些后续节点以免盲目地生成过多无用节点

  - 用于删除节点的选择，即用于决定应删除哪些无用节点以免造成进一步的时空浪费

> 估价函数一般形式

f(n) = g(n) + h(n)

- g(n)：从初始节点S0到当前节点n的代价

- h(n)：从节点n到目标节点Sg的最优路径的代价的估计，它体现了问题的启发性信息。

- f(n)：从初始节点S0到达目标节点Sg的最优路径的估计值。

## 3.2 知情搜搜——找到任何解

### 3.2.1 爬山法、最陡爬山法

> 爬山法

- 爬山法是一种贪心算法

- 爬山法是一种局部择优的方法

- 不保存未选择路径的记录

- 可能更接近顶部的目标节点就是山顶但是你可能无法从当前位置到达目标目的地

- 不存储历史记录

- 没有能力从错误中或错误路径中恢复

- 局部贪心的最优算法

> 爬山法主要思想

1. 随机选择一个登山的起点

2. 每次**拿相邻点与当前点**进行比对取两者中较优者作为爬坡的下一步

3. 重复第2步直至该点的邻近点中不再有比其大的点

4. 选择该点作为本次爬山的顶点即为该算法获得的最优解。

爬山法特点：

- 在任何一点都要做出一个选择

- 不确定是否在正确的路径上

> 最陡爬坡法

伪代码：

```C++
  Hillclimbing(Root_Node, goal){
    if(Root_Node = goal) return 成功;
    建立open表；将根节点的所有子节点插入open表；
    While(open表不为空){
      找到离目标具有最小距离的子节点；
    }end while
    最优子节点 = 离目标具有最小距离的子节点；
    if(最优子节点不是叶子结点) 以当前子节点为根结点，递归调用自身;
    else If (最优子节点 = goal) return 成功
      return 失败；
}
```

### 3.2.2 爬山法的问题

> 爬山法的问题

- 山麓问题

- 高原问题

- 山脊问题

> 山麓问题

- 可能会困在局部最大值中

- 目标状态不能从当前的位置到达

> 高原问题

相似的局部最大值

> 山脊问题

虽然可能更接近目标但是在错误的层上

> 可能的补救方法

- 回溯

- 返回到被截掉的节点

- 多次应用相同的规则(达到问题解的新区域)

- 同时应用多个规则(避免山脊问题)

### 3.2.3 最佳优先搜索算法

> 最佳优先搜索思想

1. 是智能搜索算法

2. 决定探索哪些节点

3. 实现也需要open表和closed表

4. open表中节点按照节点接近目标状态的启发式估计值进行顺序排列

5. 不会保留重复状态

6. 效率取决于所使用的启发式测度的有效性

伪代码：

```C++
  // 最佳优先搜索
  BestFirstSearch(Root_Node, goal){
    建立open表；将根节点插入open表；
    While(open表不为空){
      从open表中取出最前节点放在节点G中(同时加入closed表);
      if(G是目标节点)返回从根节点到G节点一条路径。
      while(G有子节点){
        if(子节点不在open表中)将子节点插入open表;
        else 将具有最小估计值的子节点放入open表，删除其他节点;
      } //end of second while
      将open表中节点按值排序；最小值节点在最前
    }//end of first while
    return 失败;
  }
```

## 3.3 知情搜索——找到最优解

### 3.3.1 分支定界法

> 分支定界法介绍

- 普通“分支定界法”一致代价搜索

- 搜索的估计成本为f(n) = g(n)也就是说我们只计算已经走过的道路的那部分

> 分支定界法

- 搜索的估计成本位：f(n) = g(n)

- 不采用剩余距离的启发式搜索

- 只计算已走过的部分，h(n)处处为0

> 分支定界法伪代码

```C++
  Branch_Bound(Root_Node, goal){
    创建open表
    将根节点插入open表
    While(open表不为空){
      取出open表中第一个元素放入结点G
      if(G是目标结点) Return 到G的路径
      else 将G结点子节点插入open表
      **按照从根节点到当前节点的路径长度对open表排序**
      }//end while
    Return 失败
  }
```

分支定界法与广度优先搜索最大的区别在于，广度优先搜索是努力找到通往目标的某一条路径；而分支定界法是努力要找到一条最优路径。

### 3.3.2 低估值的分支定界法

按照估计的总长度最低值生成路径

> 低估值的分支定界搜索伪代码

```C++
  B_B_Estimate(Root_Node, goal){
    创建open表
    将根节点插入open表
    While(open表不为空){
      取出open表中第一个元素放入节点G
      if(G是目标结点) return 到G的路径
      else **将每个子节点的估计距离加到当前距离**
              将节点G的子节点插入open表
              按照路径长度对open表排序
    } // end while
    Return 失败
  }
```

如何知道当前节点到目标节点的估计值呢？？？还是已知条件？？？

估计值可用当前状态与目标状态的相差度等来表示。

### 3.3.3 采用动态规划的分支定界法

动态规划基本思想：

  将待求解的问题分解为若干相关联的子问题或子阶段，按顺序求解子阶段。

  前一子问题的解，为后一子问题的求解提供了有用的信息。

  在求解任一子问题时，列出各种可能的局部解，通过决策保留哪些可能达到最优的局部解，丢弃其他局部解。

  依次解决各子问题，最后一个子问题就是问题的解。

最优路径由最优子路径构建而成。

动态规划算法的特点

- 使用最优化原理

- 无后效性

- 有重叠子问题

> 使用动态规划的分支定界法伪代码

```C++
  B_B_W_Dynamic_Programming(Root_Node, goal){
    创建open表
    将根节点插入open表
    while(open表不为空){
      取出open表中第一个元素放入节点G，并标记G被访问；
      **如果G节点之前被访问过，只保留到G的最短路径**
      if(G是目标结点) return 到G的路径
      将结点G的子节点中之前未访问过的节点插入open表
    } // end while
    return 失败
  }
```

### 3.3.4 A*搜索

这种方法采用了具有剩余距离估计值和动态规划的分支定界法

> A*搜索算法伪代码

```C++
  A* Search(Root_Node, goal){
    创建open表
    将根节点插入open表
    while(open表不为空){
      取出open表中第一个元素放入节点G，并标记G被访问；
      if(G是目标结点) return 到G的路径
      else 将每个子节点的估计距离加到当前距离
      将结点G的子节点中之前未访问过的节点插入open表
      按照长度对open表排序
    } // end while
    return 失败
  }
```

## 3.4 知情搜索——高级搜索算法

> 种类：

- 约束满足搜索

- 与/或树

- 双向搜索

### 3.4.1 高级搜索算法

在AI中，**问题简化技术**是另一个重要方法。为问题增加约束条件就可以使得问题简化。

### 3.4.2 与/或树

> 介绍

- 与/或树是用于表示问题及其求解过程

- 通常用于复杂问题的求解

- 是问题简化的技术

> 步骤

- 对于一个复杂问题，直接求解往往比较困难。此时可通过下述方法进行简化：

  - 分解

    - 把一个复杂问题分解为若干个较为简单的子问题，每个子问题又可继续分解。重复此过程，直到不需要再分解或者不能再分解为止。如此形成“与”树。

  - 等价变换

    - 利用同构或同态的等价变换，把原问题变换为若干个较为容易求解的新问题。如此形成“或”树。
  
> 与/或树基本概念

- 本原问题：不能再分解或变换而且直接可解的子问题。

- 端节点与终止节点：在与/或树中没有子节点的节点统称为端节点；本原问题所对应的节点称为终止节点。

- 可解节点

  在与/或树中，满足下列条件之一者称为可解节点：

  - 它是一个终止节点

  - 它是一个"或"节点且其子节点中至少有一个是可解节点

  - 它是一个"与"节点 且其子节点全部是可解节点。

- 不可解节点

- 关于可解节点的三个条件全部不满足的节点

### 3.4.3 双向搜索

> 双向搜索的想法

**向前搜索**目标状态 + 从目标状态**向后搜索**到起始状态

## 3.5 小结

- 搜索算法的评价指标

  - 完备性

  - 最优性

  - 可接受性

  - 单调性

- 本章介绍了启发式，以指导通过状态空间搜索潜在的合适子路径

- 如果你正在寻找解决方案：

  - 爬山法

  - 最佳优先搜索

- 如果您正在寻找最优解决方案，那么请考虑分支定界法算法中的替代方案，其中包括A*搜索。

- 与/或树有助于引导搜索

- 双向搜索是解决搜索问题的一种新方法。